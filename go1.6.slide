Go 1.6 Release Party
goMAD
17 Feb 2016

Adam Williams
@ac5w

* ¿Cuál es su experiencia con Go?

- _NIGUNA_
- _Se_que_existe_xD_
- _Aun_no_mucha..._
- _Absolutely_nothing._
- _Acabo_de_empezar_a_aprenderlo_en_mi_tiempo_libre,_me_llama_muchísimo_la_atención_:)_
- _Escasa_
- _Lo_básico_
- _just_starting_=)_
- _Experiencia_en_proyectos_personales_pequeños,_experimentos..._
- _Muchas_pruebas,_tutoriales,_videos,_scripting..._nada_en_producción_:(_
- _Ninguna,_me_gustaría_conocer_las_experiencias_de_otros_
- _Poco_

* ¿Cuál es su experiencia con Go?

- _Empecé_a_juguetear_en_2013,_hasta_acabar_en_2015_desarrollando_profesionalmente_Go_full-time._
- _Used_in_production_for_microservices_and_DevOps_tools,_currently_hurdling_more_than_1M_users_per_day_
- _Porté_Go_a_Plan_9_en_la_Raspberry_Pi._He_escrito_un_compilador_de_un_lenguaje_para_enseñanza_(picky)_multiplataforma_usando_go_y_Go_yacc._He_desarrollado_mucho_software_para_los_predecesores_de_Go_(Plan_9,_inferno),_parte_con_los_propios_desarrolladores_de_Go_(recover_con_Russ,_por_ejemplo)._Imparto_clases_de_compiladores_y_sistemas_distribuidos_en_go._

* go (in 1 slide)

Go is an open source programming language that makes it easy to build simple, reliable, and efficient software.

.play go1.6/go.go

* Sources

- http://talks.godoc.org/github.com/davecheney/gosyd/go1.6.slide
Adapted from the go Sydney user group presentation (That presentation is based _heavily_ on the [[http://tip.golang.org/doc/go1.6][official Go 1.6 release notes]]):

- https://talks.golang.org/2016/state-of-go.slide
Francesc Campoy's presentation _State_of_Go_ talk at FOSDEM

* Welcome

Today (Feb 17th) is an attempt at a release party for Go 1.6 involving as many Go user groups as possible.

.image go1.6/Go_release_party_1.6_wide.png _ 600
.caption Frédéric Menez - Digikong.io

* The Go project by the numbers

Go was announced as an open source project November 10th, 2009.

Releases occur every ~6 months, with several bug fix point releases between each major release.

Release timeline:

- [[http://blog.golang.org/the-path-to-go-1][Go 1.0]] released 28th March, 2012
- [[http://talks.golang.org/2013/go1.1.slide#1][Go 1.1]] released 13th May, 2013
- Go 1.2 released 1st December, 2013
- Go 1.3 released 18th June, 2014
- Go 1.4 released 10th December, 2014
- [[https://talks.golang.org/2015/state-of-go.slide#8][Go 1.5]] released 19th August, 2015
- Go 1.6 is expected to be released February, 2016

* Changes 1.5.x -> 1.6

- Language
- Platforms
- Tooling
- Runtime
- Standard Library

* Changes to the language

* Changes to the language

None.

This is a feature.

_-_ https://talks.golang.org/2016/state-of-go.slide#6

* Changes to the language

Most of its changes are in the implementation of the language, runtime, and libraries. There are no changes to the language specification.

As always, the release maintains the [[http://tip.golang.org/doc/go1compat.html][Go 1 compatibility guarantee]].

    "It is intended that programs written to the Go 1 specification will continue to compile
    and run correctly, unchanged, over the lifetime of that specification. At some indefinite
    point, a Go 2 specification may arise, but until that time, Go programs that work today
    should continue to work even as future "point" releases of Go 1 arise (Go 1.1, Go 1.2, etc.).

    The APIs may grow, acquiring new packages and features, but not in a way that
    breaks existing Go 1 code."

Almost all Go programs are expected to continue to compile and run as before.

* Platforms

* New Ports in 1.6

- Adds experimental ports to Linux on 64-bit MIPS (linux/mips64 and linux/mips64le). These ports support cgo but only with internal linking. Note that this is 64 bit MIPS, not the older 32 bit MIPS commonly found in routers.

- Adds an experimental port to Android on 32-bit x86 (android/386).

- On FreeBSD, Go 1.6 defaults to using clang, not gcc, as the external C compiler.

- On Linux on little-endian 64-bit PowerPC (linux/ppc64le), Go 1.6 now supports cgo with external linking and is roughly feature complete.

- On NaCl, Go 1.5 required SDK version pepper-41. Go 1.6 adds support for later SDK versions.

* Supported Platforms

Go 1.6 supports the following operating systems:

- Windows, OSX (darwin), Android, iOS, NaCl, DragonflyBSD, FreeBSD, Linux, NetBSD, OpenBSD, Plan 9, Solaris/Illumos

Go 1.6 supports the following CPU architectures:

- Intel (386 and amd64), arm (ARMv5, v6, v7), arm64, 64 bit PowerPC (big and little endian), 64 bit MIPS (big and little endian)

In the future:

- s390x (IBM Z series) planned for Go 1.7
- RISC-V may be on the horizon

* Tooling

* Tooling - cgo

Cgo enables the creation of Go packages that call C code.

.image go1.6/appenginegopher.jpg _ 600
.caption https://golang.org/doc/gopher/appenginegopher.jpg

* Tooling - cgo

The major change is the definition of rules for sharing Go pointers with C code, to ensure that such C code can coexist with Go's garbage collector.

Go and C may share memory allocated by Go when

- a pointer to that memory is passed to C as part of a cgo call,
- and provided that the memory itself contains no pointers to Go-allocated memory,
- and provided that C does not retain the pointer after the call returns.

These rules are checked by the runtime during program execution: if the runtime detects a violation, it prints a diagnosis and crashes the program.

The checks can be disabled by setting the environment variable `GODEBUG=cgocheck=0`, but note that disabling the checks will typically only lead to more mysterious failure modes.

Fixing the code in question should be strongly preferred over turning off the checks.

* Tooling - cgo

.play go1.6/cgo.go

* Tooling - parser

Externally the compiler toolchain is mostly unchanged compared to Go 1.5.

Internally, the most significant change is that the parser is now hand-written instead of generated from yacc.

Removed from parser:

  //go:generate go tool yacc go.y

* Tooling - linker

In Go 1.5 the linker's -X flag changed.

In Go 1.4 and earlier, it took two arguments, as in

    -X importpath.name value

Go 1.5 added an alternative syntax using a single argument that is itself a name=value pair:

    -X importpath.name=value

In Go 1.5 the old syntax was still accepted, after printing a warning suggesting use of the new syntax instead. Go 1.6 continues to accept the old syntax and print the warning. Go 1.7 will remove support for the old syntax.

* Tooling - linker

    package main

    import "fmt"

    var Version = "No Version Provided"

    func main() {
        fmt.Printf("App Version: %s\n", Version)
    }

Set when compiling:

    go build -ldflags "-X main.Version 1.2.3" // BAD
    go build -ldflags "-X main.Version=1.2.3" // GOOD

* Tooling - go

GO15VENDOREXPERIMENT is now enabled by default.

Go 1.5 introduced experimental support for vendoring, enabled by setting the `GO15VENDOREXPERIMENT` environment variable to 1

    GO15VENDOREXPERIMENT=1 go build // 1.5 vendoring disabled by default

Go 1.6 keeps the vendoring support, no longer considered experimental, and enables it by default.

    go build                        // 1.6 vendoring enabled by default

In Go 1.7, the environment variable will stop having any effect.

* Tooling - go

How does _vendoring_ work?

	/home/user/
	    src/
	        server-one/
	            main.go            (import "github.com/gorilla/mux")
	        server-two/
	            main.go            (import "github.com/gorilla/mux")
	            vendor/
	                github.com/
	                    gorilla/
	                        mux/
	                            ...

`server-one` uses the `mux` package in `$GOPATH/src/github.com/gorilla/mux`.

`server-two` uses the `mux` package in `vendor`.

More subtle cases exist. See [[https://golang.org/s/go15vendor]] for more info.

* Tooling - go doc

Go 1.5 added the possibility of searching by name

	go doc math Pi

Go 1.6 defines priority of packages with import paths with less elements.

An important effect of this change is that *original* copies of packages are now *preferred* over *vendored* copies. Successful searches also tend to run faster.

* Tooling - go vet

The go vet command now diagnoses passing function or method values as arguments to Printf, such as when passing f where f() was intended.

.code go1.6/vet.go

`go`vet` output:

	main.go:8: arg foo in Println call is a function value, not a function call

The warning can be removed using `%p` in the format string.

* Runtime

* Runtime - Garbage Collector

At [[https://www.youtube.com/watch?v=aiv1JOfMjm0][GopherCon 2015 Rick Hudson gave a presentation]] about the Go 1.5 low latency collector
The new collector trades throughput for reduced latency.

.image go1.6/gc1.png 450 _

* Runtime - Garbage Collector in Go 1.6

At [[http://www.infoq.com/presentations/go-gc-performance][QCon SF in November Rick Hudson]] gave an updated presentation which showed this comparison of Go 1.5 to the upcoming Go 1.6. A lot of work went into optimizing and tuning the gc, enabling far larger heaps to be managed within the 10ms latency goal.

.image go1.6/gc2.png 390 _

_Yes,_that_is_gigabytes_on_the_X_axis_

* Runtime - Maps

The runtime has added lightweight, best-effort detection of concurrent misuse of maps. As always, if one goroutine is writing to a map, no other goroutine should be reading or writing the map concurrently. If the runtime detects this condition, it prints a diagnosis and crashes the program.
_-_ _Go1.6_Release_Notes_

No performance penalty.

.image go1.6/biplane.jpg _ 350

* Runtime - Maps

.play go1.6/crash.go /const/,/Wait\(\)/

* Runtime - Uncaught Panics

For program-ending panics, the runtime now by default *prints* *only* *the* *stack* *of* *the* *running* *goroutine*, not all existing goroutines. Usually only the current goroutine is relevant to a panic, so omitting the others significantly reduces irrelevant output in a crash message.

To see the stacks from all goroutines in crash messages, set the environment variable GOTRACEBACK to all or call debug.SetTraceback before the crash, and rerun the program. See the runtime documentation for details.
_-_ _Go1.6_Release_Notes_

To see all goroutines in crash output:

    env GOTRACEBACK=all ./crashy

* Runtime - Uncaught Panics

.play go1.6/panic/main.go

* Standard Library

* Standard Library - Sorting

In the sort package, the implementation of `Sort` has been rewritten to make about *10%* fewer calls to the Interface's `Less` and `Swap` methods.

The new algorithm does choose a different ordering than before for values that compare equal (those pairs for which `Less(i,`j)` and `Less(j,`i)` are false).

The definition of `Sort` makes no guarantee about the final order of _equal_values_, the new behavior may break programs that expect a specific order.

Such programs should either refine their Less implementations to report the desired order or should switch to `sort.Stable`, which preserves the original input order of equal values.

* Standard Library - Sorting

Reminder: sort.Sort is not a _stable_ sort.

.play go1.6/sort/unstable.go /byLength/,

Use `sort.Stable`:

.play go1.6/sort/stable.go /func main/,

* Standard Library - Template

It is now possible to trim spaces around template actions, which can make template definitions *more* *readable*.

A minus sign at the beginning of an action says to trim space before the action, and a minus sign at the end of an action says to trim space after the action.

.play go1.6/template/whitespace.go /const/,/Execute/

.play go1.6/template/strip.go /const/,/Execute/

* Standard Library - Template

The new {{block}} action, combined with allowing redefinition of named templates, provides a simple way to define pieces of a template that can be replaced in different instantiations.

.image go1.6/gopher.png 250 _

* Standard Library - Template

Why do we need it? It is more compact when:

- we're not factoring out repetition,
- but we need to provide an extension point.

.play go1.6/template/block.go /^func main/,/^}/

* Standard Library - HTTP/2

Go 1.6 adds transparent support in the `net/http` package for the new HTTP/2 protocol.

.image go1.6/300px-Golang.png _ 300

* Standard Library - HTTP/2

HTTP/1.1 has been in use for 15+ years (June 1999).

Why use HTTP/2?

- Why are sprites and not individual images used?
- Why concatenate javascript & css files?
- Why shard hostnames, eg `photos1.yourdomain.es`, `photos2.yourdomain.es`, ... ?
- Why use cookieless domains eg `static.yourdomain.es`?

* Standard Library - HTTP/2

Same high level concepts:

- Methods (GET, POST, PUT, ...)
- Status Codes (404, 200, ...)
- Headers (Content-Type, ...)

Different framing of messages:

- Binary, instead of textual. Binary protocols are more efficient to parse, more compact “on the wire”, and less error-prone than textual protocols.
- Fully multiplexed, instead of ordered and blocking; can therefore use one connection for parallelism.
- Header compression to reduce overhead.
- Allows servers to "push" responses proactively into client caches.

_-https://http2.github.io/faq/_

* Standard Library - HTTP/2

How do I sign up?

"Go clients and servers will automatically use HTTP/2 as appropriate when using HTTPS. There is no exported API specific to details of the HTTP/2 protocol handling, just as there is no exported API specific to HTTP/1.1."
_-_ _Go1.6_Release_Notes_

What about HTTP? (Non-secure)

"If you want to do http2 over something other than TCP+TLS, you need to wire it up manually yourself."
_-_ _Brad_Fitzpatrick_
https://groups.google.com/d/msg/golang-nuts/ZYp7b6uoLPM/FnifhmGhGgAJ

* Standard Library - HTTP/2

.link https://http2.golang.org/gophertiles Demo 🙏

* Standard Library - HTTP/2

HTTP/1.x - 0 Latency
.video go1.6/http2/http1.0latency.mp4 video/mp4 _ 925

* Standard Library - HTTP/2

HTTP/2 - 0 Latency
.video go1.6/http2/http2.0latency.mp4 video/mp4 _ 925

* Standard Library - HTTP/2

HTTP/2 - 1s Latency
.video go1.6/http2/http2.1slatency.mp4 video/mp4 _ 925

* Standard Library - HTTP/2

HTTP/1.x - 1s Latency
.video go1.6/http2/http1.1slatency.mp4 video/mp4 _ 925

* fin
.image go1.6/party-gopher.png
